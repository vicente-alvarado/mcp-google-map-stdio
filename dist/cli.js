#!/usr/bin/env node
import{a}from"./chunk-W2DM2HDK.js";import{config as L}from"dotenv";import{resolve as R}from"path";import Ce from"yargs";import{hideBin as Ne}from"yargs/helpers";import{z as y}from"zod";import{Client as F,Language as J}from"@googlemaps/google-maps-services-js";import j from"dotenv";j.config();function m(s){let e=s?.response?.data?.error_message,r=s?.response?.status;return e?`${e} (HTTP ${r})`:s instanceof Error?s.message:String(s)}var N=class{constructor(e){this.defaultLanguage=J.en;if(this.client=new F({}),this.apiKey=e||process.env.GOOGLE_MAPS_API_KEY||"",!this.apiKey)throw new Error("Google Maps API Key is required")}async searchNearbyPlaces(e){let r={location:e.location,radius:e.radius||1e3,keyword:e.keyword,opennow:e.openNow,language:this.defaultLanguage,key:this.apiKey};try{let o=(await this.client.placesNearby({params:r})).data.results;return e.minRating&&(o=o.filter(n=>(n.rating||0)>=(e.minRating||0))),o}catch(t){throw a.error("Error in searchNearbyPlaces:",t),new Error(`Failed to search nearby places: ${m(t)}`)}}async getPlaceDetails(e){try{return(await this.client.placeDetails({params:{place_id:e,fields:["name","rating","formatted_address","opening_hours","reviews","geometry","formatted_phone_number","website","price_level","photos"],language:this.defaultLanguage,key:this.apiKey}})).data.result}catch(r){throw a.error("Error in getPlaceDetails:",r),new Error(`Failed to get place details for ${e}: ${m(r)}`)}}async geocodeAddress(e){try{let r=await this.client.geocode({params:{address:e,key:this.apiKey,language:this.defaultLanguage}});if(r.data.results.length===0)throw new Error(`No location found for address: "${e}"`);let t=r.data.results[0],o=t.geometry.location;return{lat:o.lat,lng:o.lng,formatted_address:t.formatted_address,place_id:t.place_id}}catch(r){throw a.error("Error in geocodeAddress:",r),new Error(`Failed to geocode address "${e}": ${m(r)}`)}}parseCoordinates(e){let r=e.split(",").map(t=>parseFloat(t.trim()));if(r.length!==2||isNaN(r[0])||isNaN(r[1]))throw new Error(`Invalid coordinate format: "${e}". Please use "latitude,longitude" format (e.g., "25.033,121.564"`);return{lat:r[0],lng:r[1]}}async getLocation(e){return e.isCoordinates?this.parseCoordinates(e.value):this.geocodeAddress(e.value)}async geocode(e){try{let r=await this.geocodeAddress(e);return{location:{lat:r.lat,lng:r.lng},formatted_address:r.formatted_address||"",place_id:r.place_id||""}}catch(r){throw a.error("Error in geocode:",r),new Error(`Failed to geocode address "${e}": ${m(r)}`)}}async reverseGeocode(e,r){try{let t=await this.client.reverseGeocode({params:{latlng:{lat:e,lng:r},language:this.defaultLanguage,key:this.apiKey}});if(t.data.results.length===0)throw new Error(`No address found for coordinates: (${e}, ${r})`);let o=t.data.results[0];return{formatted_address:o.formatted_address,place_id:o.place_id,address_components:o.address_components}}catch(t){throw a.error("Error in reverseGeocode:",t),new Error(`Failed to reverse geocode coordinates (${e}, ${r}): ${m(t)}`)}}async calculateDistanceMatrix(e,r,t="driving"){try{let n=(await this.client.distancematrix({params:{origins:e,destinations:r,mode:t,language:this.defaultLanguage,key:this.apiKey}})).data;if(n.status!=="OK")throw new Error(`Distance matrix calculation failed with status: ${n.status}`);let i=[],c=[];return n.rows.forEach(h=>{let l=[],g=[];h.elements.forEach(p=>{p.status==="OK"?(l.push({value:p.distance.value,text:p.distance.text}),g.push({value:p.duration.value,text:p.duration.text})):(l.push(null),g.push(null))}),i.push(l),c.push(g)}),{distances:i,durations:c,origin_addresses:n.origin_addresses,destination_addresses:n.destination_addresses}}catch(o){throw a.error("Error in calculateDistanceMatrix:",o),new Error(`Failed to calculate distance matrix: ${m(o)}`)}}async getDirections(e,r,t="driving",o,n){try{let i;n&&(i=Math.floor(n.getTime()/1e3));let c;i||(o instanceof Date?c=Math.floor(o.getTime()/1e3):o?c=o:c="now");let l=(await this.client.directions({params:{origin:e,destination:r,mode:t,language:this.defaultLanguage,key:this.apiKey,arrival_time:i,departure_time:c}})).data;if(l.status!=="OK")throw new Error(`Failed to get directions with status: ${l.status} (arrival_time: ${i}, departure_time: ${c}`);if(l.routes.length===0)throw new Error(`No route found from "${e}" to "${r}" with mode: ${t}`);let g=l.routes[0],p=g.legs[0],D=f=>{if(!f||typeof f.value!="number")return"";let z=new Date(f.value*1e3),$={year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",hour12:!1};return f.time_zone&&typeof f.time_zone=="string"&&($.timeZone=f.time_zone),z.toLocaleString(this.defaultLanguage.toString(),$)};return{routes:l.routes,summary:g.summary,total_distance:{value:p.distance.value,text:p.distance.text},total_duration:{value:p.duration.value,text:p.duration.text},arrival_time:D(p.arrival_time),departure_time:D(p.departure_time)}}catch(i){throw a.error("Error in getDirections:",i),new Error(`Failed to get directions from "${e}" to "${r}": ${m(i)}`)}}async getElevation(e){try{let r=e.map(n=>({lat:n.latitude,lng:n.longitude})),o=(await this.client.elevation({params:{locations:r,key:this.apiKey}})).data;if(o.status!=="OK")throw new Error(`Failed to get elevation data with status: ${o.status}`);return o.results.map((n,i)=>({elevation:n.elevation,location:r[i]}))}catch(r){throw a.error("Error in getElevation:",r),new Error(`Failed to get elevation data for ${e.length} location(s): ${m(r)}`)}}};var d=class{constructor(e){this.mapsTools=new N(e)}async searchNearby(e){try{let r=await this.mapsTools.getLocation(e.center),t=await this.mapsTools.searchNearbyPlaces({location:r,keyword:e.keyword,radius:e.radius,openNow:e.openNow,minRating:e.minRating});return{location:r,success:!0,data:t.map(o=>({name:o.name,place_id:o.place_id,address:o.formatted_address,location:o.geometry.location,rating:o.rating,total_ratings:o.user_ratings_total,open_now:o.opening_hours?.open_now}))}}catch(r){return{success:!1,error:r instanceof Error?r.message:"An error occurred during search"}}}async getPlaceDetails(e){try{let r=await this.mapsTools.getPlaceDetails(e);return{success:!0,data:{name:r.name,address:r.formatted_address,location:r.geometry?.location,rating:r.rating,total_ratings:r.user_ratings_total,open_now:r.opening_hours?.open_now,phone:r.formatted_phone_number,website:r.website,price_level:r.price_level,reviews:r.reviews?.map(t=>({rating:t.rating,text:t.text,time:t.time,author_name:t.author_name}))}}}catch(r){return{success:!1,error:r instanceof Error?r.message:"An error occurred while getting place details"}}}async geocode(e){try{return{success:!0,data:await this.mapsTools.geocode(e)}}catch(r){return{success:!1,error:r instanceof Error?r.message:"An error occurred while geocoding address"}}}async reverseGeocode(e,r){try{return{success:!0,data:await this.mapsTools.reverseGeocode(e,r)}}catch(t){return{success:!1,error:t instanceof Error?t.message:"An error occurred during reverse geocoding"}}}async calculateDistanceMatrix(e,r,t="driving"){try{return{success:!0,data:await this.mapsTools.calculateDistanceMatrix(e,r,t)}}catch(o){return{success:!1,error:o instanceof Error?o.message:"An error occurred while calculating distance matrix"}}}async getDirections(e,r,t="driving",o,n){try{let i=o?new Date(o):new Date,c=n?new Date(n):void 0;return{success:!0,data:await this.mapsTools.getDirections(e,r,t,i,c)}}catch(i){return{success:!1,error:i instanceof Error?i.message:"An error occurred while getting directions"}}}async getElevation(e){try{return{success:!0,data:await this.mapsTools.getElevation(e)}}catch(r){return{success:!1,error:r instanceof Error?r.message:"An error occurred while getting elevation data"}}}};import{AsyncLocalStorage as q}from"async_hooks";var K=new q;function u(){return K.getStore()?.apiKey||process.env.GOOGLE_MAPS_API_KEY}function O(s,e){return K.run(s,e)}var V="search_nearby",Y="Search for nearby places based on location, with optional filtering by keywords, distance, rating, and operating hours",Z={center:y.object({value:y.string().describe("Address, landmark name, or coordinates (coordinate format: lat,lng)"),isCoordinates:y.boolean().default(!1).describe("Whether the value is coordinates")}).describe("Search center point"),keyword:y.string().optional().describe("Search keyword (e.g., restaurant, cafe, hotel)"),radius:y.number().default(1e3).describe("Search radius in meters"),openNow:y.boolean().default(!1).describe("Only show places that are currently open"),minRating:y.number().min(0).max(5).optional().describe("Minimum rating requirement (0-5)")};async function W(s){try{let e=u(),t=await new d(e).searchNearby(s);return t.success?{content:[{type:"text",text:`location: ${JSON.stringify(t.location,null,2)}
`+JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Search failed"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error searching nearby places: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var v={NAME:V,DESCRIPTION:Y,SCHEMA:Z,ACTION:W};import{z as B}from"zod";var U="get_place_details",Q="Get detailed information about a specific place including contact details, reviews, ratings, and operating hours",X={placeId:B.string().describe("Google Maps place ID")};async function ee(s){try{let e=u(),t=await new d(e).getPlaceDetails(s.placeId);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to get place details"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error getting place details: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var E={NAME:U,DESCRIPTION:Q,SCHEMA:X,ACTION:ee};import{z as re}from"zod";var te="maps_geocode",se="Convert addresses or place names to geographic coordinates (latitude and longitude)",oe={address:re.string().describe("Address or place name to convert to coordinates")};async function ae(s){try{let e=u(),t=await new d(e).geocode(s.address);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to geocode address"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error geocoding address: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var S={NAME:te,DESCRIPTION:se,SCHEMA:oe,ACTION:ae};import{z as G}from"zod";var ne="maps_reverse_geocode",ie="Convert geographic coordinates (latitude and longitude) to a human-readable address",ce={latitude:G.number().describe("Latitude coordinate"),longitude:G.number().describe("Longitude coordinate")};async function le(s){try{let e=u(),t=await new d(e).reverseGeocode(s.latitude,s.longitude);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to reverse geocode coordinates"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error reverse geocoding: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var P={NAME:ne,DESCRIPTION:ie,SCHEMA:ce,ACTION:le};import{z as b}from"zod";var de="maps_distance_matrix",pe="Calculate travel distances and durations between multiple origins and destinations for different travel modes",ue={origins:b.array(b.string()).describe("List of origin addresses or coordinates"),destinations:b.array(b.string()).describe("List of destination addresses or coordinates"),mode:b.enum(["driving","walking","bicycling","transit"]).default("driving").describe("Travel mode for calculation")};async function ge(s){try{let e=u(),t=await new d(e).calculateDistanceMatrix(s.origins,s.destinations,s.mode);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to calculate distance matrix"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error calculating distance matrix: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var _={NAME:de,DESCRIPTION:pe,SCHEMA:ue,ACTION:ge};import{z as w}from"zod";var me="maps_directions",ye="Get detailed turn-by-turn navigation directions between two locations with route information",fe={origin:w.string().describe("Starting point address or coordinates"),destination:w.string().describe("Destination address or coordinates"),mode:w.enum(["driving","walking","bicycling","transit"]).default("driving").describe("Travel mode for directions"),departure_time:w.string().optional().describe("Departure time (ISO string format)"),arrival_time:w.string().optional().describe("Arrival time (ISO string format)")};async function he(s){try{let e=u(),t=await new d(e).getDirections(s.origin,s.destination,s.mode,s.departure_time,s.arrival_time);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to get directions"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error getting directions: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var x={NAME:me,DESCRIPTION:ye,SCHEMA:fe,ACTION:he};import{z as T}from"zod";var ve="maps_elevation",Ee="Get elevation data (height above sea level) for specific geographic locations",Se={locations:T.array(T.object({latitude:T.number().describe("Latitude coordinate"),longitude:T.number().describe("Longitude coordinate")})).describe("List of locations to get elevation data for")};async function Pe(s){try{let e=u(),t=await new d(e).getElevation(s.locations);return t.success?{content:[{type:"text",text:JSON.stringify(t.data,null,2)}],isError:!1}:{content:[{type:"text",text:t.error||"Failed to get elevation data"}],isError:!0}}catch(e){return{isError:!0,content:[{type:"text",text:`Error getting elevation data: ${e instanceof Error?e.message:JSON.stringify(e)}`}]}}}var A={NAME:ve,DESCRIPTION:Ee,SCHEMA:Se,ACTION:Pe};var be=[{name:"MCP-Server",portEnvVar:"MCP_SERVER_PORT",tools:[{name:v.NAME,description:v.DESCRIPTION,schema:v.SCHEMA,action:s=>v.ACTION(s)},{name:E.NAME,description:E.DESCRIPTION,schema:E.SCHEMA,action:s=>E.ACTION(s)},{name:S.NAME,description:S.DESCRIPTION,schema:S.SCHEMA,action:s=>S.ACTION(s)},{name:P.NAME,description:P.DESCRIPTION,schema:P.SCHEMA,action:s=>P.ACTION(s)},{name:_.NAME,description:_.DESCRIPTION,schema:_.SCHEMA,action:s=>_.ACTION(s)},{name:x.NAME,description:x.DESCRIPTION,schema:x.SCHEMA,action:s=>x.ACTION(s)},{name:A.NAME,description:A.DESCRIPTION,schema:A.SCHEMA,action:s=>A.ACTION(s)}]}],I=be;import{McpServer as _e}from"@modelcontextprotocol/sdk/server/mcp.js";import{StreamableHTTPServerTransport as we}from"@modelcontextprotocol/sdk/server/streamableHttp.js";import{isInitializeRequest as xe}from"@modelcontextprotocol/sdk/types.js";import k from"express";import{randomUUID as Ae}from"crypto";var M=class s{constructor(){this.defaultApiKey=process.env.GOOGLE_MAPS_API_KEY}static getInstance(){return s.instance||(s.instance=new s),s.instance}setDefaultApiKey(e){this.defaultApiKey=e,process.env.GOOGLE_MAPS_API_KEY=e}getApiKey(e,r){if(e){let t=e.headers["x-google-maps-api-key"];if(t)return t;let o=e.headers.authorization;if(o&&o.startsWith("Bearer "))return o.substring(7)}return r||this.defaultApiKey}hasApiKey(e,r){return!!this.getApiKey(e,r)}isValidApiKeyFormat(e){return/^[A-Za-z0-9_-]{20,50}$/.test(e)}};var Me="0.0.1",C=class{constructor(e,r){this.sessions={};this.httpServer=null;this.isStdioMode=!1;this.serverName=e,this.server=new _e({name:this.serverName,version:Me},{capabilities:{logging:{},tools:{}}}),this.registerTools(r)}registerTools(e){e.forEach(r=>{this.server.tool(r.name,r.description,r.schema,async t=>r.action(t))})}async connect(e){await this.server.connect(e),this.isStdioMode||a.log(`${this.serverName} connected and ready to process requests`)}async startHttpServer(e){this.isStdioMode=!1;let r=k();r.use(k.json()),r.post("/mcp",async(o,n)=>{let i=o.headers["mcp-session-id"],c,l=M.getInstance().getApiKey(o);if(a.log(`${this.serverName} Get API KEY: ${l}`),i&&this.sessions[i])c=this.sessions[i],l&&(c.apiKey=l);else if(!i&&xe(o.body)){let g=new we({sessionIdGenerator:()=>Ae(),onsessioninitialized:p=>{this.sessions[p]=c,a.log(`[${this.serverName}] New session initialized: ${p}`)}});c={transport:g,apiKey:l},g.onclose=()=>{g.sessionId&&(delete this.sessions[g.sessionId],a.log(`[${this.serverName}] Session closed: ${g.sessionId}`))},await this.server.connect(g)}else{n.status(400).json({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: No valid session ID provided"},id:null});return}await O({apiKey:c.apiKey,sessionId:i},async()=>{await c.transport.handleRequest(o,n,o.body)})});let t=async(o,n)=>{let i=o.headers["mcp-session-id"];if(!i||!this.sessions[i]){n.status(400).send("Invalid or missing session ID");return}let c=this.sessions[i],l=M.getInstance().getApiKey(o);l&&(c.apiKey=l),await O({apiKey:c.apiKey,sessionId:i},async()=>{await c.transport.handleRequest(o,n)})};r.get("/mcp",t),r.delete("/mcp",t),this.httpServer=r.listen(e,()=>{a.log(`[${this.serverName}] HTTP server listening on port ${e}`),a.log(`[${this.serverName}] MCP endpoint available at http://localhost:${e}/mcp`)})}async stopHttpServer(){if(!this.httpServer){a.error(`[${this.serverName}] HTTP server is not running or already stopped.`);return}return new Promise((e,r)=>{this.httpServer.close(t=>{if(t){a.error(`[${this.serverName}] Error stopping HTTP server:`,t),r(t);return}a.log(`[${this.serverName}] HTTP server stopped.`),this.httpServer=null;let o=Object.values(this.sessions).map(n=>(n.transport.sessionId&&delete this.sessions[n.transport.sessionId],Promise.resolve()));Promise.all(o).then(()=>{a.log(`[${this.serverName}] All transports closed.`),e()}).catch(n=>{a.error(`[${this.serverName}] Error during bulk transport closing:`,n),r(n)})})})}async startStdioServer(){this.isStdioMode=!0;let{StdioServerTransport:e}=await import("@modelcontextprotocol/sdk/server/stdio.js");console.error(`[${this.serverName}] Starting STDIO MCP Server...`);let r=new e;await this.connect(r),console.error(`[${this.serverName}] STDIO MCP Server ready and waiting for requests`)}async stopStdioServer(){console.error(`[${this.serverName}] Stopping STDIO MCP Server...`),process.exit(0)}};import{fileURLToPath as Te}from"url";import{dirname as Oe}from"path";import{readFileSync as Ie}from"fs";var Re=Te(import.meta.url),H=Oe(Re);L({path:R(process.cwd(),".env")});L({path:R(H,"../.env")});async function De(s,e){s&&(process.env.MCP_SERVER_PORT=s.toString()),e&&(process.env.GOOGLE_MAPS_API_KEY=e),a.log("\u{1F680} Starting Google Maps MCP Server..."),a.log("\u{1F4CD} Available tools: search_nearby, get_place_details, maps_geocode, maps_reverse_geocode, maps_distance_matrix, maps_directions, maps_elevation, echo"),a.log("");let r=I.map(async t=>{let o=process.env[t.portEnvVar];if(!o){a.error(`\u26A0\uFE0F  [${t.name}] Port environment variable ${t.portEnvVar} not set.`),a.log(`\u{1F4A1} Please set ${t.portEnvVar} in your .env file or use --port parameter.`),a.log(`   Example: ${t.portEnvVar}=3000 or --port 3000`);return}let n=Number(o);if(isNaN(n)||n<=0){a.error(`\u274C [${t.name}] Invalid port number "${o}" defined in ${t.portEnvVar}.`);return}try{let i=new C(t.name,t.tools);a.log(`\u{1F527} [${t.name}] Initializing MCP Server in HTTP mode on port ${n}...`),await i.startHttpServer(n),a.log(`\u2705 [${t.name}] MCP Server started successfully!`),a.log(`   \u{1F310} Endpoint: http://localhost:${n}/mcp`),a.log(`   \u{1F4DA} Tools: ${t.tools.length} available`)}catch(i){a.error(`\u274C [${t.name}] Failed to start MCP Server on port ${n}:`,i)}});await Promise.allSettled(r),a.log(""),a.log("\u{1F389} Server initialization completed!"),a.log("\u{1F4A1} Need help? Check the README.md for configuration details.")}async function $e(){let s=(...e)=>console.error(...e);s("\u{1F50C} Starting Google Maps MCP Server in STDIO mode..."),process.env.GOOGLE_MAPS_API_KEY||(s("\u274C Error: GOOGLE_MAPS_API_KEY not found in environment"),s("   Please set it in your .env file or environment variables"),process.exit(1));try{await new C("google-maps",I[0].tools).startStdioServer(),s("\u2705 MCP Server running in STDIO mode"),s("   Ready to receive requests from Claude Desktop"),process.stdin.resume()}catch(e){s("\u274C Failed to start STDIO server:",e),process.exit(1)}}var Ke=process.argv[1]&&(process.argv[1].endsWith("cli.ts")||process.argv[1].endsWith("cli.js")||process.argv[1].endsWith("mcp-google-map-stdio")||process.argv[1].includes("mcp-google-map-stdio")),Ge=import.meta.url===`file://${process.argv[1]}`;if(Ke||Ge)if(process.argv.includes("--stdio"))$e().catch(s=>{console.error("\u274C Fatal error:",s),process.exit(1)});else{let s="0.0.0";try{let r=R(H,"../package.json");s=JSON.parse(Ie(r,"utf-8")).version}catch{s="0.0.0"}let e=Ce(Ne(process.argv)).option("port",{alias:"p",type:"number",description:"Port to run the MCP server on",default:process.env.MCP_SERVER_PORT?parseInt(process.env.MCP_SERVER_PORT):3e3}).option("apikey",{alias:"k",type:"string",description:"Google Maps API key",default:process.env.GOOGLE_MAPS_API_KEY}).option("stdio",{type:"boolean",description:"Run in STDIO mode (for Claude Desktop)",default:!1}).option("help",{alias:"h",type:"boolean",description:"Show help"}).version(s).alias("version","v").example([["$0","Start server in HTTP mode with default settings"],['$0 --port 3000 --apikey "your_api_key"',"Start HTTP server with custom port and API key"],["$0 --stdio","Start server in STDIO mode for Claude Desktop"]]).help().parseSync();a.log("\u{1F5FA}\uFE0F  Google Maps MCP Server"),a.log("   A Model Context Protocol server for Google Maps services"),a.log(""),e.apikey||(a.log("\u26A0\uFE0F  Google Maps API Key not found!"),a.log("   Please provide --apikey parameter or set GOOGLE_MAPS_API_KEY in your .env file"),a.log("   Example: mcp-google-map-stdio --apikey your_api_key_here"),a.log("")),De(e.port,e.apikey).catch(r=>{a.error("\u274C Failed to start server:",r),process.exit(1)})}export{De as startServer};
